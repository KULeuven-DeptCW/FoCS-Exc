\documentclass{article}
\usepackage{../brackets,../proofenv,../assignment-en,../importsreferences-en}
\usetikzlibrary{automata,calc,fit,shapes,arrows}

\title{Fundamentals of Computer Science\\Solutions \#5\\\url{http://goo.gl/XS14aw}}
\author{prof. B. Demoen\\W. Van Onsem}
\date{May 2014}
\begin{document}
\maketitle
\begin{exercise}
A permutation on a set $\accl{1,\ldots,k}$ is a one-to-one, onto function on this set. When $p$ is a permutation, $p^t$ means the composition of $p$ with itself $t$ times. Let
\begin{equation}
\langdef{Perm-Power}=\condset{\tupl{p, q, t}}{p = q^t\mbox{ where $p$ and $q$ are permutations on $\accl{1,\ldots,k}$ and $t$ is a binary integer}}
\end{equation}
Show that $\langdef{Perm-Power}\in P$.
\begin{note}
Note that the most obvious algorithm does not run within polynomial time.
\end{note}
\begin{hint}
First try it where $t$ is a power of $2$.
\end{hint}
\begin{answer}
The obvious algorithm is depicted in \algoref{}. In the algorithm the permutation power is checked by repeating the permutation enough times. This
however does not work in polynomial time because the binary integer $t$ in length $n$ can scale up to $2^n$.
\paragraph{}
We can however calculate permutations to the power of $k$ with $k$ a power of $2$. In that case the algorithm runs in $\bigoh{\log_2 t}$. Since
$t=\bigoh{2^n}$, the total time complexity is $\bigoh{n}$. Pseudo-code for such algorithm is depicted in \algoref{}.
\end{answer}
\end{exercise}

\begin{exercise}
Show that NP is closed under the Kleene star operation. That is, if $L\in NP$, then $L^{\star}\in NP$.
\begin{answer}

\end{answer}
\end{exercise}

\begin{exercise}
Let $\langdef{Double-Sat}=\condset{\tupl{\phi}}{\phi\mbox{ has at least two satisfying assignments}}$. Show that $\langdef{Double-Sat}\in\mbox{NP-complete}$.
\begin{answer}
In order to do this we need to show two things: \langdef{Double-Sat} is in \cclass{NP} and there exists a reduction from \textsc{Sat} in polynomial time to \langdef{Double-Sat}. We first proof \langdef{Sat} can be reduced to \langdef{Double-Sat}:
\begin{quote}\begin{proof}
Given a Boolean function $\phi$ with variables $x_1,x_2,\ldots x_n$, we can convert it to a Boolean function $\phi'=\phi\wedge\brak{x_{n+1}\vee\neg x_{n+1}}$. In other words we've added an additional variable and a clause that is always true, whatever the value of $x_{n+1}$ is. If there is a valid assignment $\vec{x}$ for $\phi$, there are two assignments for $\phi'$ (namely the original assignment with $x_{n+1}$ true and one with $x_{n+1}$ false). If on the other hand if $\phi$ has no valid assignment, then whatever the value of $x_{n+1}$ is, there is no assignment for $\phi$. We can convert any Boolean formula $\phi$ to a formula $\phi'$ in polynomial time by enumerating over the input, counting the number of involved variables and add the defined suffix at the end of the input. We have thus reduce \langdef{Sat} to \langdef{Double-Sat} in polynomial time.
\end{proof}\end{quote}
Furthermore we need to proof that the problem is in \cclass{NP}:
\begin{quote}\begin{proof}
The \langdef{Sat} problem is in \cclass{NP} because the algorithm first branches over all the variables $\vec{x}$ and then accepts if the configuration of the active branch satisfies the given formula $\phi$. We can modify this algorithm such that it works for \langdef{Double-Sat}. In that case the algorithm branches twice over the variables generating two vector of Boolean values $\vec{v}_1$ and $\vec{v}_2$. We can check if the two value vectors are equal in polynomial time. If both vectors are identical, we reject immediately. Otherwise we check if the given formula $\phi$ on the first value vector $\vec{v}_1$ and (if successful) we validate $\vec{v}_2$ as well. Only if the two vectors are satisfied, we accept. If there are two different value assignments that can satisfy $\phi$ we will have generated a branch that accepts and the nondeterministic Turing machine will accept, if not the machine will reject. Thus \langdef{Double-Sat} is in \cclass{NP}.
\end{proof}\end{quote}
\end{answer}
\end{exercise}

\begin{exercise}
A colouring of a graph is an assignment of colours to its vertices so that no two adjacent vertices are assigned the same colour. Let
\begin{equation}
\langdef{3Colour}=\condset{\tupl{G}}{\mbox{the vertices of $G$ can be coloured with three colours such that no two vertices joined by an edge have the same colour.}}
\end{equation}
Show that $\langdef{3Colour}$ is $\mbox{NP-complete}$.
\begin{hint}
The reduction will be of the form $\mbox{3SAT}\leq_p\langdef{3Colour}$. Use the subgraphs depicted on \figref{exc48-graph1}.
\importtikzfigure{exc48-graph1}{Subgraphs used to reduce.}
\paragraph{}
The three colours correspond to true ($T$), false ($F$), and a third one (gray) to help enforce that other nodes are coloured $T$ or $F$. Each variable is modeled using the two nodes marked $w$ and $\neg w$. The first graph is used to enforce that $w$ and $\neg w$ are assigned values $T$ and $F$ or $F$ and $T$. The second graph is used to denote binary logical OR between the two legs $l$ and $r$, which may be either variables or other the roots ($\vee$) of other logical ORs. To ensure that an OR is coloured T, every root $\vee$-node is connected to $F$ and $N$.
\begin{example}
For example, the graph on \figref{exc48-graph2} corresponds to the encoding of $w\vee\neg v$.
\importtikzfigure{exc48-graph2}{Example for $w\vee\neg v$.}
\end{example}
\end{hint}
\begin{answer}

\end{answer}
\end{exercise}

\begin{exercise}
Let $\mbox{EQ}_{\mbox{\small{REX}}}=\condset{\tupl{R,S}}{\mbox{$R$ and $S$ are equivalent regular expressions}}$. Show that $\mbox{EQ}_{\mbox{\small{REX}}}\in\mbox{PSPACE}$.
\begin{answer}

\end{answer}
\end{exercise}
\end{document}