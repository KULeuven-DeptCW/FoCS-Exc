<!DOCTYPE html>
<html>
 <head>
  <link href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
  <title>The Turing machine (TM)</title>
  <script id="shader-fs" type="x-shader/x-fragment">
    	varying lowp vec4 vColor;
    	
      void main(void) {
        gl_FragColor = vColor;
      }
    </script>
    
    <!-- Vertex shader program -->
    
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec4 aVertexColor;
    
      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      
			varying lowp vec4 vColor;
    
      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
      }
    </script>
 </head>
 <body onload="webGLStart();">
 <center><canvas id="turingmachine" width="800" height="600">Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.</canvas></center>
 <script src="http://webglsamples.googlecode.com/hg/collectibles/script/CanvasMatrix.js" type="text/javascript"></script>
 <script src="https://raw.github.com/aplib/controls.js/master/controls.js" type="text/javascript"></script>
 <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
 <script language="JavaScript">
 
var mvMatrix = new CanvasMatrix4();
var rotMat = new CanvasMatrix4();
var mvMatLoc, nPhi = 50, nTheta = 25, nPhi2 = 2*(nPhi + 1);
var canvas, gl;
 function webGLStart () {	
	canvas = document.getElementById('turingmachine');
	gl = canvas.getContext('webgl') || canvas.getContext("experimental-webgl");
	var size = Math.min(window.innerWidth, window.innerHeight) - 32;
	canvas.width = size; canvas.height = size;
	gl.viewport(0, 0, size, size);
	
	gl.clearColor(0.0,0.0,0.0,1);//0.99,0.96,0.9,1
	gl.clear(gl.COLOR_BUFFER_BIT);

	/*var nChars = 6;
	var wChar = 80;
	var hChar = 80;
	var dChar = 100;
	var vertices = [];
	for (var i = 0; i <= nChars; i++ ){
		vertices.push( dChar*i );
		vertices.push( 0.5*hChar );
		vertices.push( 0.0 );
		vertices.push( dChar*i+wChar );
		vertices.push( 0.5*hChar );
		vertices.push( 0.0 );
		vertices.push( dChar*i+wChar );
		vertices.push( -0.5*hChar );
		vertices.push( 0.0 );
		vertices.push( dChar*i );
		vertices.push( -0.5*hChar );
		vertices.push( 0.0 );
	}*/
	var vertices = [
    // Front face
    -1.0, -1.0,  1.0,
     1.0, -1.0,  1.0,
     1.0,  1.0,  1.0,
    -1.0,  1.0,  1.0,
    
    // Back face
    -1.0, -1.0, -1.0,
    -1.0,  1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0, -1.0, -1.0,
    
    // Top face
    -1.0,  1.0, -1.0,
    -1.0,  1.0,  1.0,
     1.0,  1.0,  1.0,
     1.0,  1.0, -1.0,
    
    // Bottom face
    -1.0, -1.0, -1.0,
     1.0, -1.0, -1.0,
     1.0, -1.0,  1.0,
    -1.0, -1.0,  1.0,
    
    // Right face
     1.0, -1.0, -1.0,
     1.0,  1.0, -1.0,
     1.0,  1.0,  1.0,
     1.0, -1.0,  1.0,
    
    // Left face
    -1.0, -1.0, -1.0,
    -1.0, -1.0,  1.0,
    -1.0,  1.0,  1.0,
    -1.0,  1.0, -1.0
  ];
  var colors = [
    [1.0,  1.0,  1.0,  1.0],    // Front face: white
    [1.0,  0.0,  0.0,  1.0],    // Back face: red
    [0.0,  1.0,  0.0,  1.0],    // Top face: green
    [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue
    [1.0,  1.0,  0.0,  1.0],    // Right face: yellow
    [1.0,  0.0,  1.0,  1.0]     // Left face: purple
  ];
  
  var generatedColors = [];
  
  for (j=0; j<6; j++) {
    var c = colors[j];
    
    for (var i=0; i<4; i++) {
      generatedColors = generatedColors.concat(c);
    }
  }
  
  cubeVerticesIndexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
  
  // This array defines each face as two triangles, using the
  // indices into the vertex array to specify each triangle's
  // position.
  
  var cubeVertexIndices = [
    0,  1,  2,      0,  2,  3,    // front
    4,  5,  6,      4,  6,  7,    // back
    8,  9,  10,     8,  10, 11,   // top
    12, 13, 14,     12, 14, 15,   // bottom
    16, 17, 18,     16, 18, 19,   // right
    20, 21, 22,     20, 22, 23    // left
  ]
  
  // Now send the element array to GL
  
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
      new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
  
  /*cubeVerticesColorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesColorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(generatedColors), gl.STATIC_DRAW);
//	var vBuffer = gl.createBuffer();
//	gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
//	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	gl.vertexPointer(buffer, 3, gl.FLOAT, false, 0, 0);
	//gl.enableVertexAttribArray(vBuffer);
	
	glVertexPointer(3,GL_FLOAT,0,vertices);
	glColorPointer(3,GL_FLOAT,0,colors);
	

//	gl.enable(gl.DEPTH_TEST);
//	gl.depthFunc(gl.LEQUAL);
//	gl.clearDepth(1.0);*/
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVerticesIndexBuffer);
	//setMatrixUniforms();
	gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
	gl.flush();alert("foo");
 }
</script>
 
 <script id="shader-vs" type="x-shader/x-vertex"> 
  attribute vec3 aPos; // Normals = Pos
  attribute vec2 aTexCoord;
  uniform mat4 mvMatrix;
  uniform mat4 prMatrix;
  varying vec2 vTexCoord;
  varying float i;
  const vec4 dirDif = vec4(0., 0., 1., 0.);
  const vec4 dirHalf = vec4(-.4034, .259, .8776, 0.);
  void main(void) {
	vTexCoord = aTexCoord;
	gl_Position = prMatrix * mvMatrix * vec4(aPos, 1.);
	vec4 rotNorm = mvMatrix * vec4(aPos, .0);
	i = max( 0., dot(rotNorm, dirDif) );
	i += .3* pow( max( 0., dot(rotNorm, dirHalf) ), 40.);
  }
 </script> 
 
 <script id="shader-fs" type="x-shader/x-fragment"> 
  precision mediump float;
  uniform sampler2D uTexSamp;
  varying vec2 vTexCoord;
  varying float i;
  void main(void) {
	vec4 c = texture2D(uTexSamp, vTexCoord);
	gl_FragColor = vec4(i * c.rgb, 1.);
  }
 </script> 
</body>
</html>
